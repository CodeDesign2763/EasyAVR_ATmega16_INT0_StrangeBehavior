# MWE для исследования странного поведения стенда EasyAVR6 при работе с внешними прерываниями

## Оборудование

Стенд [EasyAVR6](http://www.rlx.sk/mikroelektronika/easyavr6_manual_v101.pdf) с микроконтроллером [ATmega16](http://ww1.microchip.com/downloads/en/devicedoc/doc2466.pdf).

Схема подключения кнопок для **PD2**, **PD3** из официального руководства к EasyAVR6:

![Схема подключения кнопок для PD2, PD3](./Pictures/PortsIO2.png)

Положение джамперов и переключателей можно оценить по следующей фотографии:

![Фотография стенда во время 2-й лабораторной работы](./Pictures/jumpers.png)

## Суть программы:

1. Зажечь на стенде **EasyAVR6** светодиоды, соответствующие **PA3-PA7**. 

2. При нажатии на кнопку **PD2**, соотв. вектору прерывания **INT0** светодиоды для **PA3-PA7** должны погаснуть.

```
#define F_CPU 1000000
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>

ISR(INT0_vect) {

    /* Гасим светодиоды для порта А */
    PORTA=0x00;

}

int main(void)
{
    НАСТРОЙКА_ПОРТОВ_ВВОДА_ВЫВОДА;
    /* Зажигаем светодиоды для порта A */
    PORTA=0xF0;

    /* Настройка прерываний */
    /* Разрешение прерываний с векторами INT0 и INT1 */
    GICR |= (1 << INT1) | (1 << INT0);

    /* Срабатывание INT0 по спаду импульса */
    MCUCR |= (1 << ISC01) | (0 << ISC00);

    while (1) 
    {
    }

}
```

## Cуть странного поведения:

Странное поведение впервые зафиксировано автором во время участия во 2-й лабораторной работе по дисциплине "Схемотехника" 10.04.2021.

При нажатии на кнопку, соответствующую **PD2** cветодиоды для порта **A** должны гаснуть, *но при испытании на стенде этого не происходит*. 

При добавлении в код обработчика прерывания **INT0** команды `_delay_ms` было замечено, что *светодиоды гаснут лишь на время обусловленной ей задержки*.

Во время лабораторной работы проблему удалось решить лишь при помощи дополнительной глобальной переменной: ее значение изменялось в обработчике прерываний, а в основном цикле значение регистра **PORTA** менялось в зависимости от ее значения при помощи условного оператора. 

    #define F_CPU 1000000
    #include <avr/io.h>
    #include <util/delay.h>
    #include <avr/interrupt.h>
    
    unsigned char globalVar=0;
    ISR(INT0_vect) {
        /* Гасим светодиоды для порта А */
        globalVar=1;
    }
    
    int main(void)
    {
        НАСТРОЙКА_ПОРТОВ_ВВОДА_ВЫВОДА;
        PORTA=0xF0;
    
        /* Настройка прерываний */
        /* Разрешение прерываний с векторами INT0 и INT1 */
        GICR |= (1 << INT1) | (1 << INT0);
    
        /* Срабатывание INT0 по спаду импульса */
        MCUCR |= (1 << ISC01) | (0 << ISC00);
    
        while (1) 
        {
            if (globalVar==1) PORTA=0x00;
        }
    }

## MWE

[MWE](https://en.wikipedia.org/wiki/Minimal_working_example) - наиболее простая программа минимального размера, демонстрирующая какую-либо ошибку. В рамках данного исследования подготовлено 3 версии такой программы: ветка [J13_VCC](https://github.com/CodeDesign2763/EasyAVR_ATmega16_INT0_StrangeBehavior), ветка [J13_GND](https://github.com/CodeDesign2763/EasyAVR_ATmega16_INT0_StrangeBehavior/tree/J13_GND), ветка [Floating_PD2_PD3](https:////github.com/CodeDesign2763/EasyAVR_ATmega16_INT0_StrangeBehavior/tree/Floating_PD2_PD3). 

Наиболее близкой к оригинальному коду, вызывавшему странное поведение, является версия №3 (ветка **Floating_PD2_PD3**). Файл [main.c](https://github.com/CodeDesign2763/EasyAVR_ATmega16_INT0_StrangeBehavior/blob/Floating_PD2_PD3/EasyAVR6_ATmega16_INT0_StrangeBehavior/main.c). Версия №2 предназначена для случая, когда джампер **J13** находится в положении **GND**.

## Исследование странного поведения.

### Гипотеза №1

*В начале процедуры обработки прерывания содержимое регистра **PORTA** заносится в стек, а затем, в конце процедуры, извлекается из него.*

Гипотеза не подтвердилась.

### Гипотеза №2

Исследуем положение джамперов и переключателей с опубликованной выше схемы:

1. Джамперы **J1**- **J4** отключены.
2. Переключатели **SW1** и **SW4** находятся в состоянии **0xFF**
3. Джампер **J13** находится в положении **"VCC"**.

Очевидно, что находящиеся в режиме чтения выводы **PD2** и **PD3** не подтянуты к 0 и *"висят в воздухе"* при ненажатых кнопках, что делает поведение МК непредсказуемым.

Наиболее реалистичной кажется следующая гипотеза, объясняющее упомянутое выше странное поведение: 

1. В программе разрешены внешние прерывания **INT0** и **INT1**.
2. Обработчик прерывания объявлен лишь для **INT0**.
3. Выводы **PD2** и **PD3** не подтянуты к 0 и "висят в воздухе" при ненажатых кнопках.
4. При нажатии на кнопку **T26**, соответствующую **PD2**, также возникает прерывание **INT1**.
5. Возможные причины возникновения **INT1**: появление в цепи вывода **PD3** наводки при нажатии на кнопку **T26**, работа светодиода **LD27** в режиме фотодиода при свечении светодиода **LD26** на фоне отсутствия подтягивания к 0 вывода **PD3**.
6. Т.к. у регистра **SREG** бит **I=0**, а у **GICR** бит **INT1=1**, то у регистра **GIFR** биту **INTF1** присваивается 1.
7. Как только обработка прерывания **INT0** завершается, то у регистра **SREG** биту **I** присваивается 1 и начинается обработка прерывания **INT1**, т.к. у регистра **GIFR** бит **INTF1=1**.
8. Поскольку у **INT1** нет обработчика, как нет их и у прерываний с более низким приоритетом, управление передается на область памяти программ, заполненную нулями, которые интерпретируются как инструкции **NOP**, которая предшествует основной программе.
9. После выполнения этих инструкций **NOP** микроконтроллер начинает выполнять основную программу, в начале которой восстанавливается исходное значения регистра **PORTA**, что полностью отменяет все изменения, произведенные в обработчике прерывания **INT0**.

### План эксперимента

![План эксперимента](./Pictures/block_diagr_exp.png)

Данная блок-схема создана при помощи автоматического генератора блок-схем [Code2Flow](https://app.code2flow.com/). [Код](./block_diagr_exp.code2flow) блок-схемы.

### Результаты эксперимента

Состояние стенда перед экспериментом:

![Cостояние стенда перед экспериментом](./Pictures/EasyAVR_GOODRES.png)

Первое, что нужно отметить - нижнее положение движков переключателей **SW1-SW4** соответствует отключенному состоянию, что не совсем очевидно на схеме из инструкции к стенду.  Следовательно, перед экспериментом **J13** находится в положении **"VCC"**, **J1-J4** в нейтральном положении, **SW1-SW4** в состоянии 0x00. 

Программа из ветки **Floating_PD2_PD3** не вызывала описанного выше странного поведения: при нажатии на кнопку **T26**, соответствующую прерыванию **INT0**, светодиоды, подключенные к выводам порта **A**, гасли и автоматически вновь не зажигались. Следовательно, **гипотеза №2 неверна**.

Чтобы светодиоды порта **A** в данном опыте вновь зажглись, достаточно было нажимать на кнопку **T27**, соответствующую прерыванию **INT1** - тогда, как и предполагалось выше, ввиду отсутствия обработчика прерывания **INT1** и прерываний с меньшим приоритетом, прерывание **INT1** [приводило к повторному выполнению основной программы](https://youtu.be/Ws4GtpN9Rdw), однако прерывание **INT0** само по себе при описанном состоянии стенда не вызывало автоматически прерывания **INT1** и, соответственно, "странного поведения". 

[Воспроизвести "странное поведение" удалось](https://youtu.be/dFkjAH3sLOI) после того, как была закомментирована строчка кода, устанавливающая режим генерации прерывания **INT1** по спаду импульса (см. ветку [ISC_Error](https://github.com/CodeDesign2763/EasyAVR_ATmega16_INT0_StrangeBehavior/tree/ISC_Error)). Оказалось, что по умолчанию, когда биты **ISC11** и **ISC10** регистра **MCUCR** равны 0, действует режим генерирования прерывания по уровню 0, что при описанных выше настройках **J4**, **SW4** и **J13** ("висящий в воздухе" PD2), равноценно постоянной генерации прерывания **INT1**.

## Причина странного поведения

По результатам эксперимента было [зафиксировано](https://youtu.be/dFkjAH3sLOI) описанное выше "странное поведение" и установлена его точная причина, которая стала результатом сочетания следующих факторов:

1.	Положение джамперов **J4**, **J13** и состояние переключателя **SW4** при отключенной внутренней подтяжке к 1 (через DDRD и PORTD) приводили  к тому, что находившийся в режиме чтения вывод **PD2** "висел в воздухе".
2.	В программе было разрешено внешнее прерывание **INT1**, но его обработчик не был объявлен. 
3. 	Обработчики прерываний с приоритетом, меньшим чем **INT1** также не были объявлены. 
4. 	Для прерывания **INT1** в регистре **MCUCR** был установлен режим генерации прерываний по уровню 0 (режим по умолчанию), что приводило к постоянной генерации данного прерывания.
5. 	Поскольку обработчик данного прерывания не был объявлен, как и обработчики прерываний с меньшим приоритетом, то при возникновении **INT1** происходило повторное выполнение основной программы, при котором фактически отменялись все изменения, произошедшие в обработчике прерываний **INT0**, что и было причиной "странного поведения". 



